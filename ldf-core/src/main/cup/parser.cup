package ldf.parser.gen;
import ldf.java_cup.runtime.*;
import ldf.parser.ast.*;
import ldf.parser.ast.BnfAtom.AtomType;

import java.util.List;
import java.util.LinkedList;

/* -------------- Terminals ---------------- */

terminal String  IDENTIFIER;
terminal Number  NUMBER;

terminal
    STRING_BEGIN, STRING_END, CHAR_BEGIN, CHAR_END;

terminal String
    STRING_FRAGMENT,
    INVALID_ESCAPE_SEQ;

/* Keywords: */

terminal
    GRAMMAR, NTERM, WHERE, VAR, DEF,       // declarations
    IF, ELSE, SWITCH, CASE, DEFAULT,       // branching
    FOR, DO, WHILE, BREAK, CONTINUE,       // looping
    RETURN, TRY, CATCH, FINALLY,           // jumps
    NEW, TRUE, FALSE;                      // other

/* Punctuation */

terminal
    COLON, SEMICOLON, COMMA, DOT, AT_SIGN, Q_MARK,    // : ; , . @ ?
    PIPE, HAT, PLUS, MINUS, TIMES, SLASH, MOD,        // | ^ ~ + - * / %
    PLUS_PLUS, MINUS_MINUS, EXCL, PIPE_PIPE, AMP_AMP, // ++ -- ! || &&
    EQ, EQEQ, NEQ, LT, LTE, GT, GTE,                  // = == != < <= > >=
    COLON_COLON_EQ, ELLIPSIS, EQ_GT;                  // ::=  ... =>

/* Different kinds of parentheses and brackets: */

terminal
    LPAREN, RPAREN,   // ( ... )
    LSQUARE, RSQUARE, // [ ... ]
    LCURLY, RCURLY,   // { ... }
    LCURLY_AT_SIGN,   // {@ ...
    LACTION, RACTION, // {: ... :}
    LGUARD, RGUARD;   // {? ... ?}

/* ------------- Non-terminals ------------- */

non terminal
    literal_char,
    literal_str,
    string_contents_,
    string_contents__;

non terminal BnfSyntax          bnf_syntax;
non terminal BnfJoin            bnf_join;
non terminal BnfMeet            bnf_meet;
non terminal BnfAbstractAction  bnf_action;
non terminal BnfAtom            bnf_atom, bnf_atom_;
non terminal BnfMultiplicity    bnf_multiplicity;

non terminal Declaration        decl;
non terminal DeclList           decl_list;
non terminal DeclVars           decl_vars, decl_vars_;
non terminal DeclVariable       decl_var__;
non terminal DeclFunction       decl_function;

non terminal DeclGrammar        decl_grammar;

non terminal List<ExprReference>
    decl_grammar_extend_,
    decl_grammar_extend__;

non terminal DeclNonTerminal decl_nterm;

non terminal DeclWhereClause
    decl_nterm_where_,
    decl_nterm_where_entries_;

non terminal DeclWhereClauseEntry
    decl_nterm_where_entry_;

non terminal StmtList stmt_list;

non terminal Statement
    stmt,
    stmt_block,
    stmt_empty,
    stmt_expr,
    stmt_switch,
    switch_body_,
    stmt_decl,
    stmt_label,
    stmt_try,
    stmt_catch_,
    stmt_catch__;

non terminal Statement
    matched, unmatched; //for solving the dangling else problem

non terminal TypeExpression
    type_expr;

non terminal Expression
    expr, expr_join, expr_meet, expr_bool, expr_additive,
    expr_multiplicative, expr_exponential, expr_primary,
    expr_secondary, expr_assign;

non terminal ExprReference expr_reference;

non terminal ExprList
    expr_list, expr_list_;

non terminal Expression
    expr_list_item;

non terminal  main;

/* -------------- Productions -------------- */

start with main;

main
    ::= decl_grammar:gram
        {:  RESULT = gram;  :}
    ;

/* literals */
literal_char        // '...'
    ::= CHAR_BEGIN string_contents_ CHAR_END;

literal_str         // "..."
    ::= STRING_BEGIN string_contents_ STRING_END;

string_contents_    // sequence of valid (and invalid) bits of a string
    ::= string_contents__ string_contents_
    |   /* empty */
    ;

string_contents__   // the invalid bits will get flagged
    ::= STRING_FRAGMENT
    |   INVALID_ESCAPE_SEQ
    ;

/* Declarations */

decl_grammar
    ::= GRAMMAR IDENTIFIER:id decl_grammar_extend_:ext
        LCURLY decl_list:decl RCURLY
        {:
            RESULT = new DeclGrammar(id, ext, decl);
        :}
    ;

decl_grammar_extend_
    ::= COLON decl_grammar_extend__:ext
        {:  RESULT = ext;   :}

    |   /* empty */
    ;

decl_grammar_extend__
    ::= decl_grammar_extend__:ext COMMA expr_reference:ref
        {:  (RESULT = ext).add(ref);    :}

    |   expr_reference:ref
        {:
            RESULT = new LinkedList<ExprReference>();
            RESULT.add(ref);
        :}
    ;

decl_list
    ::= decl_list:list decl:decl
        {:  (RESULT = list).add(decl);  :}

    |   /* empty */
        {:  RESULT = new DeclList();    :}
    ;

decl
    ::= decl_vars:vars      {:  RESULT = vars;  :}
    |   decl_function:fn    {:  RESULT = fn;    :}
    |   decl_nterm:nterm    {:  RESULT = nterm; :}
    ;

decl_vars   // var ...;
    ::= VAR decl_vars_:vars SEMICOLON
        {:  RESULT = vars;  :}
    ;

decl_vars_
    ::= decl_vars_:vars COMMA decl_var__:var
        {:  (RESULT = vars).add(var);   :}

    |   decl_var__:var
        {:  (RESULT = new DeclVars()).add(var);   :}
    ;

decl_var__     // identifier [ : type ] [ = expr ]
    ::= IDENTIFIER:id
        {:  RESULT = new DeclVariable(id, null, null);  :}

    |   IDENTIFIER:id COLON type_expr:t
        {:  RESULT = new DeclVariable(id, t, null);     :}

    |   IDENTIFIER:id EQ expr:e
        {:  RESULT = new DeclVariable(id, null, e);     :}

    |   IDENTIFIER:id COLON type_expr:t EQ expr:e
        {:  RESULT = new DeclVariable(id, t, e);        :}
    ;

decl_function
    ::= DEF IDENTIFIER:id expr_list:args stmt_block:body
        {:  RESULT = new DeclFunction(id, args, null, body);    :}

    |   DEF IDENTIFIER:id expr_list:args
        COLON type_expr:type
        stmt_block:body
        {:  RESULT = new DeclFunction(id, args, type, body);    :}

    ;

/* Declarative statements (grammar definition) */

decl_nterm          // nterm ID ::= ... [where ...] ;
    ::= NTERM IDENTIFIER:id
        COLON_COLON_EQ bnf_syntax:bnf
        decl_nterm_where_:where_clause
        SEMICOLON
        {:
            RESULT = new DeclNonTerminal(id, bnf, where_clause);
        :}
    ;

decl_nterm_where_   // where @id = {: action code :} ...
    ::= WHERE decl_nterm_where_entries_:list
        {:  RESULT = list;  :}
    | /* empty */
    ;

decl_nterm_where_entries_
    ::= decl_nterm_where_entries_:list  // iteration
        decl_nterm_where_entry_:item    // item
        {:  (RESULT = list).add(item);  :}

    |   /* empty */
        {:  RESULT = new DeclWhereClause(); :}
    ;

decl_nterm_where_entry_ // @identifier = {: action code :}
    ::= AT_SIGN IDENTIFIER:id EQ bnf_action:a
        {:  RESULT = new DeclWhereClauseEntry(id, a);   :}
    ;

/* BNF syntax */

bnf_syntax
    ::= bnf_join:root
        {:  RESULT = new BnfSyntax(root);   :}
    ;

bnf_join        // a|b|c|... (precedence: 0)
    ::= bnf_join:join PIPE bnf_meet:meet
        {:  (RESULT = join).add(meet);  :}

    |   bnf_meet:meet
        {:
            RESULT = new BnfJoin();
            RESULT.add(meet);
        :}
    ;

bnf_meet        // a b c ... (precedence: 1)
    ::= bnf_meet:meet bnf_atom:obj
        {:  (RESULT = meet).add(obj);   :}

    |   bnf_meet:meet bnf_action:obj
        {:  (RESULT = meet).add(obj);   :}

    |   /* empty */
        {:  RESULT = new BnfMeet();     :}
    ;

bnf_action
    ::= // {: ... :} -- action to be executed
        LACTION stmt_list:s RACTION
        {:  RESULT = new BnfAction(s);  :}

    |   // {? ... ?} -- condition to be checked
        LGUARD expr:e RGUARD
        {:  RESULT = new BnfGuard(e);   :}

    |   // {@label} -- placeholder to be expanded in the "where" clause
        LCURLY_AT_SIGN IDENTIFIER:id RCURLY
        {:  RESULT = new BnfPlaceholder(id);  :}
    ;

// [label@] something [multiplicity]
bnf_atom
    ::= bnf_atom_:a
        {:  RESULT = a; :}

    |   IDENTIFIER:id AT_SIGN bnf_atom_:a
        {:
            RESULT = a;
            a.setLabel(id);
        :}

    |   IDENTIFIER:id AT_SIGN bnf_atom_:a bnf_multiplicity:m
        {:
            RESULT = a;
            a.setLabel(id);
            a.setMultiplicity(m);
        :}

    |   bnf_atom_:a bnf_multiplicity:m
        {:
            RESULT = a;
            a.setMultiplicity(m);
        :}
    ;

bnf_atom_
    ::= expr_reference:ref
        {:
            RESULT = new BnfAtom(AtomType.REFERENCE, ref);
        :}

    |   literal_char:chr
        {:
            RESULT = new BnfAtom(AtomType.LITERAL_CHAR, chr);
        :}

    |   literal_str:str
        {:
            RESULT = new BnfAtom(AtomType.LITERAL_STRING, str);
        :}

    |   LPAREN bnf_join:bnf RPAREN
        {:
            RESULT = new BnfAtom(AtomType.BNF_JOIN, bnf);
        :}


    |   LSQUARE bnf_join:e1 COMMA bnf_join:e2 RSQUARE
        {:
            RESULT = new BnfAtom(
                AtomType.ALTERNATION,
                new BnfAlternation(e1, e2)
            );
        :}
    ;

bnf_multiplicity        // used after a bnf_atom_ to indicate repetition
    ::= TIMES                                   // * = 0 or more
        {:  RESULT = new BnfMultiplicity("*", 0, null);     :}

    |   PLUS                                    // + = 1 or more
        {:  RESULT = new BnfMultiplicity("+", 1, null);     :}

    |   Q_MARK                                  // ? = 0 or 1
        {:  RESULT = new BnfMultiplicity("?", 0, 1);        :}

    |   LCURLY NUMBER:n RCURLY                  // {n}   = exactly n
        {:  RESULT = new BnfMultiplicity("{n}", n, n);      :}

    |   LCURLY NUMBER:n COMMA RCURLY            // {n,}  = n or more
        {:  RESULT = new BnfMultiplicity("{n,}", n, null);  :}

    |   LCURLY NUMBER:n COMMA NUMBER:m RCURLY   // {n,m} = between n and m
        {:  RESULT = new BnfMultiplicity("{n,m}", n, m);    :}

    |   LCURLY COMMA NUMBER:n RCURLY            // {,n}  = n or less
        {:  RESULT = new BnfMultiplicity("{,n}", null, n);  :}
    ;

/* Imperative statements (action body) */

stmt_list
    ::= stmt_list stmt
    |   /* empty */
    ;

stmt
    ::= matched   // these two solve the dangling else problem
    |   unmatched // http://www.cs.man.ac.uk/~pjj/complang/g2lr.html#5
    ;

unmatched
    ::= IF LPAREN expr RPAREN stmt
    |   IF LPAREN expr RPAREN matched ELSE unmatched

    /* for-else (syntactic sugar) */
    |   FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN stmt
    |   FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN matched
        ELSE unmatched

    /* while-else (syntactic sugar) */
    |   WHILE LPAREN expr RPAREN stmt
    |   WHILE LPAREN expr RPAREN matched ELSE unmatched

    |   stmt_label unmatched
    |   ELLIPSIS // dummy statement
    ;

matched
    ::= IF LPAREN expr RPAREN matched ELSE matched

    /* for-else (syntactic sugar) */
    |   FOR LPAREN expr SEMICOLON expr SEMICOLON expr RPAREN matched
        ELSE matched

    /* while-else (syntactic sugar) */
    |   WHILE LPAREN expr RPAREN matched
        ELSE matched

    |   DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    |   BREAK    SEMICOLON
    |   CONTINUE SEMICOLON
    |   BREAK    IDENTIFIER SEMICOLON
    |   CONTINUE IDENTIFIER SEMICOLON
    |   RETURN expr SEMICOLON
    |   stmt_block
    |   stmt_empty
    |   stmt_expr
    |   stmt_switch
    |   stmt_decl
    |   stmt_label matched
    |   stmt_try
    ;

stmt_decl
    ::= decl_vars
    ;

stmt_label
    ::= IDENTIFIER COLON
    ;

stmt_block      // { ... code ... }
    ::= LCURLY stmt_list RCURLY
    ;

stmt_empty      // ;
    ::= SEMICOLON
    ;

stmt_expr       // expr;
    ::= expr SEMICOLON
    ;

stmt_switch     // switch(expr) { ... }
    ::= SWITCH LPAREN expr RPAREN LCURLY
            switch_body_
        RCURLY
    ;

switch_body_
    ::= CASE expr COLON switch_body_
    |   DEFAULT COLON   switch_body_
    |   stmt            switch_body_
    |   /* empty */
    ;

stmt_try
    ::= TRY LCURLY stmt_list RCURLY stmt_catch_
    |   TRY LCURLY stmt_list RCURLY stmt_catch_
        FINALLY LCURLY stmt_list RCURLY
    ;

stmt_catch_
    ::= stmt_catch_ stmt_catch__
    |   stmt_catch__
    ;

stmt_catch__
    ::= CATCH LPAREN type_expr IDENTIFIER RPAREN
        LCURLY stmt_list RCURLY
    ;

/* Type expressions (needs expanding) */

type_expr
    ::= IDENTIFIER;

/* Lists: (a, b, c) or (a: int, b: char, c: T) */

expr_list
    ::= LPAREN expr_list_:list RPAREN
        {:  RESULT = list;  :}
    ;

expr_list_
    ::= expr_list_:list COMMA expr_list_item:item
        {:  (RESULT = list).add(item);  :}

    |   expr_list_item:item
        {:  (RESULT = new ExprList()).add(item);    :}

    |   /* empty */
        {:  RESULT = new ExprList();    :}
    ;

expr_list_item
    ::= IDENTIFIER COLON type_expr  // formal parameter
    |   expr                        // actual parameter
    ;

/* Expression statements */

expr
    ::= expr_assign;

expr_assign
    ::= expr_join EQ expr_assign
    |   expr_join
    ;

expr_join
    ::= expr_join PIPE_PIPE  expr_meet
    |   expr_meet
    ;

expr_meet
    ::= expr_meet AMP_AMP    expr_bool
    |   expr_bool
    ;
expr_bool
    ::= expr_bool EQEQ expr_additive
    |   expr_bool NEQ  expr_additive
    |   expr_bool LT   expr_additive
    |   expr_bool LTE  expr_additive
    |   expr_bool GT   expr_additive
    |   expr_bool GTE  expr_additive
    |   expr_additive
    ;

expr_additive
    ::= expr_additive PLUS  expr_multiplicative
    |   expr_additive MINUS expr_multiplicative
    |   expr_multiplicative
    ;

expr_multiplicative
    ::= expr_multiplicative TIMES  expr_exponential
    |   expr_multiplicative SLASH  expr_exponential
    |   expr_multiplicative  MOD   expr_exponential
    |   expr_exponential
    ;

expr_exponential
    ::= expr_secondary HAT expr_exponential
    |   expr_secondary
    ;

expr_secondary
    ::= EXCL         expr_secondary
    |   MINUS        expr_secondary
    |   PLUS         expr_secondary
    |   PLUS_PLUS    expr_primary
    |   MINUS_MINUS  expr_primary
    |   expr_primary PLUS_PLUS
    |   expr_primary MINUS_MINUS
    |   expr_primary EQ_GT stmt_block
    |   expr_primary EQ_GT expr_primary
    |   expr_primary
    ;

expr_primary
    ::= literal_char
    |   literal_str
    |   NUMBER
    |   TRUE
    |   FALSE
    |   expr_list
    |   expr_reference
    |   expr_primary LSQUARE expr RSQUARE           // array access
    |   expr_primary expr_list                      // function call
    |   NEW expr_reference expr_list                // object creation
    ;

expr_reference
    ::= expr_reference:r DOT IDENTIFIER:id
        {:  (RESULT = r).addFirst(id);  :}

    |   IDENTIFIER:id
        {:  (RESULT = new ExprReference()).addFirst(id);    :}
    ;
